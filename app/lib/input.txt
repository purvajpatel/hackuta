// Grammar Definition for PyStock Language

PROGRAM = STATEMENT+;

STATEMENT = (VAR_ASSIGN | PRINT_STMT | IF_STMT | FUNC_CALL) SEMI;

VAR_ASSIGN = ID EQ EXPR;
PRINT_STMT = PRINT LPAREN EXPR RPAREN;
IF_STMT = IF EXPR LBRACE PROGRAM RBRACE;

EXPR = TERM ((PLUS | MINUS) TERM)*;
TERM = FACTOR ((MUL | DIV) FACTOR)*;
FACTOR = (LPAREN EXPR RPAREN) | FLOAT | ID | FUNC_CALL | LIST;

FUNC_CALL = ID LPAREN (EXPR (COMMA EXPR)*)? RPAREN;
LIST = LBRACKET (EXPR (COMMA EXPR)*)? RBRACKET;

tok SEMI = ";"
tok EQ = "="
tok PRINT = "print"
tok IF = "if"
tok LPAREN = "("
tok RPAREN = ")"
tok LBRACE = "{"
tok RBRACE = "}"
tok LBRACKET = "["
tok RBRACKET = "]"
tok COMMA = ","
tok PLUS = "+"
tok MINUS = "-"
tok MUL = "*"
tok DIV = "/"

tok (
	ID = (std::istream &s) {
		std::string buf;
		auto c = s.get();
		if (std::isalpha(c) || c == '_') {
			buf.push_back(c);
			for (c = s.get(); std::isalnum(c) || c == '_'; c = s.get())
				buf.push_back(c);
			s.unget();
			char *buffer = new char[buf.size() + 1];
			memcpy(buffer, buf.data(), buf.size());
			buffer[buf.size()] = 0;
			return { Token::ID, buffer };
		}
		s.unget();
		return Token::failed;
	}

	FLOAT = (std::istream &s) {
		std::string buf;
		char c = s.get();
		while (std::isdigit(c)) {
			buf.push_back(c);
			c = s.get();
		}
		if (c == '.') {
			buf.push_back(c);
			c = s.get();
			while (std::isdigit(c)) {
				buf.push_back(c);
				c = s.get();
			}
		}
		s.unget();
		if (buf.empty() || buf.back() == '.')
			return Token::failed;

		char *buffer = new char[buf.size() + 1];
		memcpy(buffer, buf.data(), buf.size());
		buffer[buf.size()] = 0;
		return { Token::FLOAT, buffer };
	}
)

skip (
	WHITESPACE = (std::istream &s) {
		for (auto c = s.get(); std::isspace(c); c = s.get()) {}
		s.unget();
	}

	COMMENT = (std::istream &s) {
        if (s.peek() == '#') {
            while (s.get() != '\n' && !s.eof()) {}
        } else {
            return Token::failed;
        }
        return { Token::COMMENT, nullptr };
    }
)



#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <variant>
#include <numeric>
#include <stdexcept>
#include <memory>

/*
=================================================
 Example PyStock Code to be Interpreted
=================================================

# Define a list of stock prices
price_data = [150.25, 152.50, 151.75, 153.00, 155.50, 154.75, 156.00, 158.25, 157.50, 159.00];

# Calculate the 5-period Simple Moving Average
sma_val = SMA(price_data, 5);
print(sma_val);

# Calculate the 5-period Exponential Moving Average
ema_val = EMA(price_data, 5);
print(ema_val);

# Calculate the 7-period Relative Strength Index
rsi_val = RSI(price_data, 7);
print(rsi_val);

# Simple conditional logic
threshold = 60.0;
if RSI(price_data, 7) > threshold {
    print(1.0); # Represents a "buy" signal
}

=================================================
*/

// --- Type System ---
struct Value;
using ValueList = std::vector<Value>;
using ValueVec = std::vector<double>;

struct Value {
    std::variant<std::monostate, double, ValueVec> data;

    double as_double() const {
        if (auto* p = std::get_if<double>(&data)) return *p;
        throw std::runtime_error("Type error: expected a double.");
    }

    ValueVec as_vec() const {
        if (auto* p = std::get_if<ValueVec>(&data)) return *p;
        throw std::runtime_error("Type error: expected a list of numbers.");
    }
};

std::ostream& operator<<(std::ostream& os, const Value& val) {
    if (auto* p = std::get_if<double>(&val.data)) {
        os << *p;
    } else if (auto* p = std::get_if<ValueVec>(&val.data)) {
        os << "[";
        for (size_t i = 0; i < p->size(); ++i) {
            os << (*p)[i] << (i == p->size() - 1 ? "" : ", ");
        }
        os << "]";
    } else {
        os << "null";
    }
    return os;
}

using SymbolTable = std::unordered_map<std::string, Value>;

// --- Forward Declarations ---
Value evaluate_node(ParseTree::Node* node, SymbolTable& symbols);
Value call_builtin_function(const std::string& func_name, const ValueList& args);

// --- Built-in Technical Analysis Functions ---

Value sma(const ValueList& args) {
    if (args.size() != 2) throw std::runtime_error("SMA requires 2 arguments: data list and period.");
    ValueVec data = args[0].as_vec();
    int period = static_cast<int>(args[1].as_double());
    if (period <= 0 || data.size() < static_cast<size_t>(period)) {
         throw std::runtime_error("Invalid period or insufficient data for SMA.");
    }
    double sum = std::accumulate(data.end() - period, data.end(), 0.0);
    return { sum / period };
}

Value ema(const ValueList& args) {
    if (args.size() != 2) throw std::runtime_error("EMA requires 2 arguments: data list and period.");
    ValueVec data = args[0].as_vec();
    int period = static_cast<int>(args[1].as_double());
    if (period <= 0 || data.empty()) {
        throw std::runtime_error("Invalid period or insufficient data for EMA.");
    }
    double multiplier = 2.0 / (period + 1.0);
    double ema_val = data[0];
    for (size_t i = 1; i < data.size(); ++i) {
        ema_val = (data[i] - ema_val) * multiplier + ema_val;
    }
    return { ema_val };
}

Value rsi(const ValueList& args) {
    if (args.size() != 2) throw std::runtime_error("RSI requires 2 arguments: data list and period.");
    ValueVec data = args[0].as_vec();
    int period = static_cast<int>(args[1].as_double());
    if (period <= 0 || data.size() < static_cast<size_t>(period) + 1) {
        throw std::runtime_error("Insufficient data for RSI calculation (need period + 1).");
    }

    double gain = 0.0, loss = 0.0;
    for (size_t i = 1; i <= static_cast<size_t>(period); ++i) {
        double change = data[i] - data[i-1];
        if (change > 0) gain += change;
        else loss -= change;
    }
    double avg_gain = gain / period;
    double avg_loss = loss / period;

    for (size_t i = period + 1; i < data.size(); ++i) {
        double change = data[i] - data[i-1];
        gain = (change > 0) ? change : 0.0;
        loss = (change < 0) ? -change : 0.0;
        avg_gain = (avg_gain * (period - 1) + gain) / period;
        avg_loss = (avg_loss * (period - 1) + loss) / period;
    }

    if (avg_loss == 0) return { 100.0 };
    double rs = avg_gain / avg_loss;
    return { 100.0 - (100.0 / (1.0 + rs)) };
}


// --- Interpreter ---

Value evaluate_expression(ParseTree::Node* node, SymbolTable& symbols) {
    if (node->type == ParseTree::TERM) {
        Value left = evaluate_node(node->children[0], symbols);
        for (size_t i = 1; i < node->children.size(); i += 2) {
            ParseTree::Node* op_node = node->children[i];
            Value right = evaluate_node(node->children[i+1], symbols);
            if (op_node->type == ParseTree::MUL) {
                left.data = left.as_double() * right.as_double();
            } else if (op_node->type == ParseTree::DIV) {
                if (right.as_double() == 0) throw std::runtime_error("Division by zero.");
                left.data = left.as_double() / right.as_double();
            }
        }
        return left;
    }
    
    if (node->type == ParseTree::EXPR) {
        Value left = evaluate_node(node->children[0], symbols);
        for (size_t i = 1; i < node->children.size(); i += 2) {
            ParseTree::Node* op_node = node->children[i];
            Value right = evaluate_node(node->children[i+1], symbols);
            if (op_node->type == ParseTree::PLUS) {
                left.data = left.as_double() + right.as_double();
            } else if (op_node->type == ParseTree::MINUS) {
                left.data = left.as_double() - right.as_double();
            }
        }
        return left;
    }
    return evaluate_node(node, symbols); // Fallback for single-node expressions
}

Value evaluate_node(ParseTree::Node* node, SymbolTable& symbols) {
    switch (node->type) {
        case ParseTree::PROGRAM:
            for (auto* child : node->children) {
                evaluate_node(child, symbols);
            }
            return {};
        case ParseTree::STATEMENT:
            return evaluate_node(node->children[0], symbols);
        case ParseTree::VAR_ASSIGN: {
            std::string var_name = node->children[0]->data;
            Value val = evaluate_expression(node->children[1], symbols);
            symbols[var_name] = val;
            return {};
        }
        case ParseTree::PRINT_STMT: {
            Value val = evaluate_expression(node->children[0], symbols);
            std::cout << val << std::endl;
            return {};
        }
        case ParseTree::IF_STMT: {
             Value condition = evaluate_expression(node->children[0], symbols);
             if (condition.as_double() > 0) { // Pythonic truthiness (non-zero is true)
                evaluate_node(node->children[1], symbols);
             }
             return {};
        }
        case ParseTree::EXPR:
        case ParseTree::TERM:
            return evaluate_expression(node, symbols);
        case ParseTree::FACTOR:
            return evaluate_node(node->children[0], symbols);
        case ParseTree::FUNC_CALL: {
            std::string func_name = node->children[0]->data;
            ValueList args;
            for (size_t i = 1; i < node->children.size(); ++i) {
                args.push_back(evaluate_expression(node->children[i], symbols));
            }
            return call_builtin_function(func_name, args);
        }
        case ParseTree::LIST: {
            ValueVec vec;
            for (auto* child : node->children) {
                vec.push_back(evaluate_expression(child, symbols).as_double());
            }
            return { vec };
        }
        case ParseTree::ID: {
            std::string var_name = node->data;
            if (symbols.find(var_name) == symbols.end()) {
                throw std::runtime_error("Undefined variable '" + var_name + "'.");
            }
            return symbols[var_name];
        }
        case ParseTree::FLOAT:
            return { std::stod(node->data) };
        default:
            throw std::runtime_error("Unhandled parse tree node type.");
    }
}

Value call_builtin_function(const std::string& func_name, const ValueList& args) {
    if (func_name == "SMA") {
        return sma(args);
    } else if (func_name == "EMA") {
        return ema(args);
    } else if (func_name == "RSI") {
        return rsi(args);
    }
    throw std::runtime_error("Undefined function '" + func_name + "'.");
}

void interpret(ParseTree::Node* root) {
    if (!root) {
        std::cerr << "Error: Provided parse tree root is null." << std::endl;
        return;
    }
    SymbolTable global_symbols;
    try {
        evaluate_node(root, global_symbols);
    } catch (const std::runtime_error& e) {
        std::cerr << "Runtime Error: " << e.what() << std::endl;
    }
}