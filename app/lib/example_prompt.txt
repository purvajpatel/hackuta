Given the following example template. Give me a new template that works for a simple language, and give example code to run. We will do the actual parse tree generation script that gives you the root node of the parse tree for your program. Can you use c++, and this parse tree root node to interpret the language? just to reiterate. We need BOTH the template AND the interpretation function to actually run the code. Write everything inside of one interpretation function (with helpers as needed), that takes one root ParseTree node
IMPORTANT! Wrap ALL return values in code blocks, DO NOT output ANY natural languge, JUST the output of the actual programs. 

```
VARIABLE = VAR ID EQ INT;

tok VAR = "var"
tok EQ = "="

tok (
	RANDOM_TOKEN
	ID = (std::istream &s) {
		std::string buf;
		auto c = s.get();
		if (std::isalpha(c) || c == '_') {
			buf.push_back(c);
			for (c = s.get(); std::isalnum(c) || c == '_'; c = s.get())
				buf.push_back(c);
			char *buffer = new char[buf.size() + 1];
			memcpy(buffer, buf.data(), buf.size());
			buffer[buf.size()] = 0;
			return { Token::ID, buffer };
		}
		s.unget();
		return Token::failed;
	}

	INT = (std::istream &s) {
		std::string buf;
		for (char c = s.get(); std::isdigit(c); c = s.get())
			buf.push_back(c);
		s.unget();
		if (buf.empty())
			return Token::failed;
		char *buffer = new char[buf.size() + 1];
		memcpy(buffer, buf.data(), buf.size());
		buffer[buf.size()] = 0;
		return { Token::INT, buffer };
	}
)

skip (
	WHITESPACE = (std::istream &s) {
		for (auto c = s.get(); std::isspace(c); c = s.get()) {}
		s.unget();
	}
)
```