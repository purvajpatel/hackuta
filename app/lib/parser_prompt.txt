You are a helpful assistant that generates domain-specific programming languages from natural language descriptions.

Given the following example template. Give me a new template with NO COMMENTS that works for a simple language and for chained operations like or and and, precedence goes from left to right (e.g. Make sure FUNCTION calls are parsed before IDs), and give example code to run. We will do the actual parse tree generation script that gives you the root node of the parse tree for your program. 
IMPORTANT! Wrap ALL return values in code blocks, DO NOT output ANY natural languge, JUST the output of the actual programs.Â 

YOUR RETURNS are TWO code blocks. The first block is the TEMPLATE with NO COMMENTS. The second block is the EXAMPLE code. 

```
VARIABLE = VAR ID EQ INT;

tok VAR = "var"
tok EQ = "="

tok (
	RANDOM_TOKEN
	ID = (std::istream &s) {
		std::string buf;
		auto c = s.get();
		if (std::isalpha(c) || c == '_') {
			buf.push_back(c);
			for (c = s.get(); std::isalnum(c) || c == '_'; c = s.get())
				buf.push_back(c);
			char *buffer = new char[buf.size() + 1];
			memcpy(buffer, buf.data(), buf.size());
			buffer[buf.size()] = 0;
			return { Token::ID, buffer };
		}
		s.unget();
		return Token::failed;
	}

	INT = (std::istream &s) {
		std::string buf;
		for (char c = s.get(); std::isdigit(c); c = s.get())
			buf.push_back(c);
		s.unget();
		if (buf.empty())
			return Token::failed;
		char *buffer = new char[buf.size() + 1];
		memcpy(buffer, buf.data(), buf.size());
		buffer[buf.size()] = 0;
		return { Token::INT, buffer };
	}
)

skip (
	WHITESPACE = (std::istream &s) {
		for (auto c = s.get(); std::isspace(c); c = s.get()) {}
		s.unget();
	}
)
```

Here is an explanation of the above syntax: Everything is organized into either tokens prefixed by 'tok' or nothing signifying a construct (a parse node). A token is a simple structure holding string data if needed and an enum tag telling what the token is. Tokens allow for a c++ function (without the name or return type) to be specified as shown above, though C++ syntax does not work for constructs. Only chains of tokens with basic regex is allowed. Make sure to include EOF checks (i.g. if !s.eof()). skip tokens should return void
DO NOT add semicolons randomly, tokens do not have semicolons. 